<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>ConcurrentBinaryMinHeap: Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ConcurrentBinaryMinHeap
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A .NET 3.5 C# implementation of a thread-safe binary min-heap, suitable for implementation of a priority queue.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The ConcurrentBinaryMinHeap class is a thread-safe generic binary heap for sorting such that the largest element is always the root element. This heap uses the min-heap property, therefore the element with the highest priority will always be removed first.  
 <a href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.png" usemap="#Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;_map" alt=""/>
  <map id="Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;_map" name="Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54b0b819a24d95681b5fe8079568efd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a54b0b819a24d95681b5fe8079568efd1">ConcurrentBinaryMinHeap</a> ()</td></tr>
<tr class="memdesc:a54b0b819a24d95681b5fe8079568efd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new default heap.  <a href="#a54b0b819a24d95681b5fe8079568efd1">More...</a><br /></td></tr>
<tr class="separator:a54b0b819a24d95681b5fe8079568efd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace378fd08e67ff35c0b81cb0d4c2dc9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#ace378fd08e67ff35c0b81cb0d4c2dc9e">ConcurrentBinaryMinHeap</a> (int initialCapacity)</td></tr>
<tr class="memdesc:ace378fd08e67ff35c0b81cb0d4c2dc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new heap with the given initial size of the array implementing it internally.  <a href="#ace378fd08e67ff35c0b81cb0d4c2dc9e">More...</a><br /></td></tr>
<tr class="separator:ace378fd08e67ff35c0b81cb0d4c2dc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ae9c93acb53d0e91f780a6d00cfcf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a31ae9c93acb53d0e91f780a6d00cfcf0">Add</a> (PriorityValuePair&lt; T &gt; element)</td></tr>
<tr class="memdesc:a31ae9c93acb53d0e91f780a6d00cfcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a PriorityValuePair as a new element into the heap.  <a href="#a31ae9c93acb53d0e91f780a6d00cfcf0">More...</a><br /></td></tr>
<tr class="separator:a31ae9c93acb53d0e91f780a6d00cfcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53faf7ae81d8bffb5fcefa312b872a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a53faf7ae81d8bffb5fcefa312b872a94">Clear</a> ()</td></tr>
<tr class="memdesc:a53faf7ae81d8bffb5fcefa312b872a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all elements from the heap.  <a href="#a53faf7ae81d8bffb5fcefa312b872a94">More...</a><br /></td></tr>
<tr class="separator:a53faf7ae81d8bffb5fcefa312b872a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c43e93176afdf05424179c007be8fac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a0c43e93176afdf05424179c007be8fac">Contains</a> (PriorityValuePair&lt; T &gt; element)</td></tr>
<tr class="memdesc:a0c43e93176afdf05424179c007be8fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the heap contains the given PriorityValuePair element.  <a href="#a0c43e93176afdf05424179c007be8fac">More...</a><br /></td></tr>
<tr class="separator:a0c43e93176afdf05424179c007be8fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe42c659c59aed0907876a1620dca01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a0fe42c659c59aed0907876a1620dca01">CopyTo</a> (PriorityValuePair&lt; T &gt;[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a0fe42c659c59aed0907876a1620dca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the heap to an Array, starting at a particular index. This method does not guarantee that elements will be copied in the sorted order.  <a href="#a0fe42c659c59aed0907876a1620dca01">More...</a><br /></td></tr>
<tr class="separator:a0fe42c659c59aed0907876a1620dca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8002827f6bb9ba3d98cd09222fece1"><td class="memItemLeft" align="right" valign="top">IEnumerator&lt; PriorityValuePair<br class="typebreak" />
&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a9a8002827f6bb9ba3d98cd09222fece1">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a9a8002827f6bb9ba3d98cd09222fece1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through the heap's elements. This enumerator is not guaranteed to iterate through elements in sorted order, and indeed, is not even guaranteed to iterate through elements by priority (although in general the iterated elements will tend from high to low priority values).  <a href="#a9a8002827f6bb9ba3d98cd09222fece1">More...</a><br /></td></tr>
<tr class="separator:a9a8002827f6bb9ba3d98cd09222fece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49273243c2545b67ed67ee861f3da0"><td class="memItemLeft" align="right" valign="top">PriorityValuePair&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a1b49273243c2545b67ed67ee861f3da0">Peek</a> ()</td></tr>
<tr class="memdesc:a1b49273243c2545b67ed67ee861f3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current root element of the heap, but don't remove it.  <a href="#a1b49273243c2545b67ed67ee861f3da0">More...</a><br /></td></tr>
<tr class="separator:a1b49273243c2545b67ed67ee861f3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7d605273fdbc30fad9a2cd3e608e90"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a0d7d605273fdbc30fad9a2cd3e608e90">PeekPriority</a> ()</td></tr>
<tr class="memdesc:a0d7d605273fdbc30fad9a2cd3e608e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the priority of the current root element of the heap, but don't remove it.  <a href="#a0d7d605273fdbc30fad9a2cd3e608e90">More...</a><br /></td></tr>
<tr class="separator:a0d7d605273fdbc30fad9a2cd3e608e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa1d4a578bdaf7b87e43a0dd9c5119"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a2faa1d4a578bdaf7b87e43a0dd9c5119">PeekValue</a> ()</td></tr>
<tr class="memdesc:a2faa1d4a578bdaf7b87e43a0dd9c5119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the current root element of the heap, but don't remove it.  <a href="#a2faa1d4a578bdaf7b87e43a0dd9c5119">More...</a><br /></td></tr>
<tr class="separator:a2faa1d4a578bdaf7b87e43a0dd9c5119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7744ec34d5a0a12aed617fe8419ef"><td class="memItemLeft" align="right" valign="top">PriorityValuePair&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#ab6e7744ec34d5a0a12aed617fe8419ef">Pop</a> ()</td></tr>
<tr class="memdesc:ab6e7744ec34d5a0a12aed617fe8419ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted.  <a href="#ab6e7744ec34d5a0a12aed617fe8419ef">More...</a><br /></td></tr>
<tr class="separator:ab6e7744ec34d5a0a12aed617fe8419ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcc1f52182b629a19af496d5f0fabef"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a7fcc1f52182b629a19af496d5f0fabef">PopPriority</a> ()</td></tr>
<tr class="memdesc:a7fcc1f52182b629a19af496d5f0fabef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the priority of the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted.  <a href="#a7fcc1f52182b629a19af496d5f0fabef">More...</a><br /></td></tr>
<tr class="separator:a7fcc1f52182b629a19af496d5f0fabef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5c66e4eae404ebfdd8c06c3f0f6f2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a39a5c66e4eae404ebfdd8c06c3f0f6f2">PopValue</a> ()</td></tr>
<tr class="memdesc:a39a5c66e4eae404ebfdd8c06c3f0f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted.  <a href="#a39a5c66e4eae404ebfdd8c06c3f0f6f2">More...</a><br /></td></tr>
<tr class="separator:a39a5c66e4eae404ebfdd8c06c3f0f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60657b171f002ed15edddff41afb9e6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a60657b171f002ed15edddff41afb9e6c">Push</a> (PriorityValuePair&lt; T &gt; element)</td></tr>
<tr class="memdesc:a60657b171f002ed15edddff41afb9e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element into the heap and heapify it into its correct position, given an existing PriorityValuePair containing a float priority as its key and a value.  <a href="#a60657b171f002ed15edddff41afb9e6c">More...</a><br /></td></tr>
<tr class="separator:a60657b171f002ed15edddff41afb9e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599c6f9ce88cb1d83aebebf4bb9198fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a599c6f9ce88cb1d83aebebf4bb9198fb">Push</a> (float priority, T value)</td></tr>
<tr class="memdesc:a599c6f9ce88cb1d83aebebf4bb9198fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element into the heap and heapify it into its correct position, given a float priority and some value to create an element from.  <a href="#a599c6f9ce88cb1d83aebebf4bb9198fb">More...</a><br /></td></tr>
<tr class="separator:a599c6f9ce88cb1d83aebebf4bb9198fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966dd9dac9ee5d42adaaf7d4c3096d85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a966dd9dac9ee5d42adaaf7d4c3096d85">Remove</a> (PriorityValuePair&lt; T &gt; element)</td></tr>
<tr class="memdesc:a966dd9dac9ee5d42adaaf7d4c3096d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first occurrence of the given PriorityValuePair element within the heap.  <a href="#a966dd9dac9ee5d42adaaf7d4c3096d85">More...</a><br /></td></tr>
<tr class="separator:a966dd9dac9ee5d42adaaf7d4c3096d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a78a3adad031ae8fde9384f56cfc511e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a78a3adad031ae8fde9384f56cfc511e8">Capacity</a><code> [get]</code></td></tr>
<tr class="memdesc:a78a3adad031ae8fde9384f56cfc511e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements the heap can hold without auto-resizing.  <a href="#a78a3adad031ae8fde9384f56cfc511e8">More...</a><br /></td></tr>
<tr class="separator:a78a3adad031ae8fde9384f56cfc511e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ca74d0f3de062ee7860928dc1273e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a498ca74d0f3de062ee7860928dc1273e">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a498ca74d0f3de062ee7860928dc1273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the heap.  <a href="#a498ca74d0f3de062ee7860928dc1273e">More...</a><br /></td></tr>
<tr class="separator:a498ca74d0f3de062ee7860928dc1273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eb001d9f4c344d8fea2112f11bef10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a38eb001d9f4c344d8fea2112f11bef10">IsEmpty</a><code> [get]</code></td></tr>
<tr class="memdesc:a38eb001d9f4c344d8fea2112f11bef10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the heap is empty.  <a href="#a38eb001d9f4c344d8fea2112f11bef10">More...</a><br /></td></tr>
<tr class="separator:a38eb001d9f4c344d8fea2112f11bef10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb803c373a5373ecdbf6fad45d3a93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html#a8ceb803c373a5373ecdbf6fad45d3a93">IsReadOnly</a><code> [get]</code></td></tr>
<tr class="memdesc:a8ceb803c373a5373ecdbf6fad45d3a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the collection is read-only. For a heap this property returns <code>false</code>.  <a href="#a8ceb803c373a5373ecdbf6fad45d3a93">More...</a><br /></td></tr>
<tr class="separator:a8ceb803c373a5373ecdbf6fad45d3a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The ConcurrentBinaryMinHeap class is a thread-safe generic binary heap for sorting such that the largest element is always the root element. This heap uses the min-heap property, therefore the element with the highest priority will always be removed first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data to be queued.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a54b0b819a24d95681b5fe8079568efd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.ConcurrentBinaryMinHeap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new default heap. </p>

</div>
</div>
<a class="anchor" id="ace378fd08e67ff35c0b81cb0d4c2dc9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.ConcurrentBinaryMinHeap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new heap with the given initial size of the array implementing it internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The initial size of the data List internal to the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Thrown by the List constructor when the given initialCapacity is less than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a31ae9c93acb53d0e91f780a6d00cfcf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">PriorityValuePair&lt; T &gt;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a PriorityValuePair as a new element into the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>PriorityValuePair to add as a new element.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53faf7ae81d8bffb5fcefa312b872a94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all elements from the heap. </p>

</div>
</div>
<a class="anchor" id="a0c43e93176afdf05424179c007be8fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">PriorityValuePair&lt; T &gt;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the heap contains the given PriorityValuePair element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The PriorityValuePair to locate in the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item is found in the heap; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a0fe42c659c59aed0907876a1620dca01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">PriorityValuePair&lt; T &gt;[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements of the heap to an Array, starting at a particular index. This method does not guarantee that elements will be copied in the sorted order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional Array that is the destination of the elements copied from the heap. The Array must have zero-based indexing. </td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The zero-based index in array at which copying begins.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a8002827f6bb9ba3d98cd09222fece1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerator&lt; PriorityValuePair&lt;T&gt; &gt; Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through the heap's elements. This enumerator is not guaranteed to iterate through elements in sorted order, and indeed, is not even guaranteed to iterate through elements by priority (although in general the iterated elements will tend from high to low priority values). </p>
<dl class="section return"><dt>Returns</dt><dd>An generic enumerator of the heap's contents.</dd></dl>

</div>
</div>
<a class="anchor" id="a1b49273243c2545b67ed67ee861f3da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PriorityValuePair&lt;T&gt; Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current root element of the heap, but don't remove it. </p>

</div>
</div>
<a class="anchor" id="a0d7d605273fdbc30fad9a2cd3e608e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.PeekPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the priority of the current root element of the heap, but don't remove it. </p>

</div>
</div>
<a class="anchor" id="a2faa1d4a578bdaf7b87e43a0dd9c5119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.PeekValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the current root element of the heap, but don't remove it. </p>

</div>
</div>
<a class="anchor" id="ab6e7744ec34d5a0a12aed617fe8419ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PriorityValuePair&lt;T&gt; Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted. </p>

</div>
</div>
<a class="anchor" id="a7fcc1f52182b629a19af496d5f0fabef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.PopPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the priority of the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted. </p>

</div>
</div>
<a class="anchor" id="a39a5c66e4eae404ebfdd8c06c3f0f6f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.PopValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the current root element of the heap, and then remove it. This operation will heapify the heap after removal to ensure that it remains sorted. </p>

</div>
</div>
<a class="anchor" id="a60657b171f002ed15edddff41afb9e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">PriorityValuePair&lt; T &gt;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new element into the heap and heapify it into its correct position, given an existing PriorityValuePair containing a float priority as its key and a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>A PriorityValuePair containing a float priority as its key and a generically-typed value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a599c6f9ce88cb1d83aebebf4bb9198fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new element into the heap and heapify it into its correct position, given a float priority and some value to create an element from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>A float priority.</td></tr>
    <tr><td class="paramname">value</td><td>A generically-typed object.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a966dd9dac9ee5d42adaaf7d4c3096d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">PriorityValuePair&lt; T &gt;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first occurrence of the given PriorityValuePair element within the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The PriorityValuePair element to remove from the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item was successfully removed from the priority heap. This method returns <code>false</code> if item is not found in the collection.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a78a3adad031ae8fde9384f56cfc511e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements the heap can hold without auto-resizing. </p>

</div>
</div>
<a class="anchor" id="a498ca74d0f3de062ee7860928dc1273e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in the heap. </p>

</div>
</div>
<a class="anchor" id="a38eb001d9f4c344d8fea2112f11bef10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.IsEmpty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the heap is empty. </p>

</div>
</div>
<a class="anchor" id="a8ceb803c373a5373ecdbf6fad45d3a93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Axon.Collections.ConcurrentBinaryMinHeap&lt; T &gt;.IsReadOnly</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the collection is read-only. For a heap this property returns <code>false</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ConcurrentBinaryMinHeap/<a class="el" href="_concurrent_binary_min_heap_8cs.html">ConcurrentBinaryMinHeap.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_axon.html">Axon</a></li><li class="navelem"><a class="el" href="namespace_axon_1_1_collections.html">Collections</a></li><li class="navelem"><a class="el" href="class_axon_1_1_collections_1_1_concurrent_binary_min_heap_3_01_t_01_4.html">ConcurrentBinaryMinHeap< T ></a></li>
    <li class="footer">Generated on Mon Dec 29 2014 23:49:00 for ConcurrentBinaryMinHeap by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
